# организация ввода/вывода в C программах

в языке C отсутствует оператор отвечающий за обмен данными с внешними устройствами

этот обмен реализуется с помощью функций стандартной библиотеки ввода/вывода, спецификации которых указанны в файле stdio.h, где h сокращение от header 

для включения в файл программы заголовочного файла, используется директива препроцессора include, котарая включает вместо строки директивы текст файла, указанного в качестве параметра этой директивы, имени заключенного в угловые скобки или двойный кавычки

    #include <stdio.h>

при указании угловых скобок препроцессора для поиска файла с указыным именем просматривает директории указанные в переменной интегрированной среды разработки программ или в качетсве соответствующего параметра при вызове компилятора из командной строки

при использовании двойных кавычек, препроцессор пытается найти указанный файл в текущей дириктории, а так же в директориях указаных в переменной среды окружения командного процессора (INCLUDE, PATH)

после стадий компиляции, на этапе редактирования связей, компановщик разрешает внешние ссылки, разыскивая по имени функции ее код в библиотечном файле, который подключается автоматически в случае стандартной библиотеки, либо имя которого указывается явно в опциях компоновщика при его вызове из командной строки, либо в переменной IDE 

для организации ввода/вывода используется понятия потока ввода/вывода, которые фактически представляют собой последовательность байтов, которые отправляются либо на стандартное утсройства вывода используемое по умолчанию, либо в файл, связь с которым предварительно должна быть установлена с помощью функции открытия файла для записи, результатом которой будет файловая переменая, связанная с физическим файлом на внешнем запоминающем устройстве и вывод в который будет осуществляться с помощью функций операционной системы

аналогично ввод информации осуществляется либо из стандартного потока ввода (с клавиатуры), либо из файла, открываемого для чтения

в стандартной библиотеки C присутствуют два типа функций ввода/вывода

- форматированный ввод/вывод { scanf, printf, fscanf, fprintf }
- двоичный или бинарный ввод/вывод { read, write }

так же при использовании форматированного ввода/вывода в/из файла, файлы для чтения и записи могут быть открыты в:

- текстовом режиме (t)
- в бинарном режиме (b)

текстовый режим отличается от бинарного интерпритацией символа конца строки

при чтении в текстовым режиме, пары символов \n\r заменяются однима символовм  \n, а при выводе \n в \n\r (в бинарном редиме поток обмена не происходит)

printf функция форматированного вывода ...

примечание: стандартный поток вывода может быть заменен на файл при запуске программы из командной строки с указанием ей в качестве параметра символа больше и имени файла для вывода И символа меньше м имени фалйа для ввода

фармальные параметры функции printf:

- первый (обязательный) - тип строка (указатель на символ)
    
    назаничение: выводимый текст и спецификаторы вывода, который начинается со знака %, за которым следуют символы: 

    - с - для строк
    - d - для целых чисел
    - f - для вещественных чисел

- далее через запятую необязательные параметры, идентификаторы, имена переменных или выражения, значения которых выводятся в соответствии с интерпритацией спецификатора выводы 

следующего по порядку в строке спецификаций на месте соответствующего выводимому значению 

    #include <stdio.h>
    
    int main() {
        int a, b;
        printf("%d + %d = %d", a, b, a+b);

        return 0;
    }

спецификация вывода содержит строку из символов, три символа начинаются со знака % ... как вывод целых чисел

при выполнении этой программы на экран выведется произвольное число, далле плюс, далле произвольное число, далле знак равенства, далее сумма произвольных чисел

printf(char*, ...)

функция ввода из стандартного потока scanf(char*, ...)

первый параметр строка как и в printf, зачем через апятую выражения, определяющие адресс область памяти ... куда будет помещенно значение из потока ввода, которое будет приведенно к формату хранения в соответствии с типом указным в качестве спецификатора ввода для этого выражения 

например 
    
    #include <stdio.h>
    
    int main() {
        int a, b;
        printf("%d + %d = %d", a, b, a+b);
        scanf("%d%d", &a, &b);

        return 0;
    }

scanf является примером функции параметрами которыми передаются по ссылке, а не по значению (как в printf)

передавая в функцию адрес переменной, мы получаем внутри функции доступ к области памяти в которой размещенно значение переменной изменяя которое, мы изменяем значение соответствующей переменно в вызавающей функции 

передавая параметры по значению (как в printf), внутри вызванной функции мы получаем копию значения переменной, которое записываем в переменную формальный параметр, которое будет уничтоженно при возврате из функции (она перестанет быть доступной, а память которую она занимала, будет использоваться для других переменных)

изменения значения формального параметра в этом случае никак не влияет на значение переменной в вызывающей функции, которая была использованна в качестве фактического параметра

функция fprintf(FILE*, char*, ...)/fscanf(FILE*, char*, ...) отличаются от printf(char*, ...)/scanf(char*, ...) тем, что у них два обязательных парметра. первый - указатель на файл, второй - строка спецификации вывода и дальше выводимых значений

    FILE *f; 
    f = fopen("name", "tr"); // открыть файл (вернет указатель)
    feof(f);   // проверка достигнут ли конец файла
    fclose(f); // закрытие файла

все операции чтения необходимо производить при истинности условия !focf(f)

после проверки необходимо закрыть файл 

файловая переменная - это указатель на структуру, соответствующую описанию файла в операционной системе (FCB)

количество одновременно открываемых файлов, ограниченно операционной системой и может задаваться пользователем в переменной среды окружения FILES

если не закрыть файл

  - может быть потерянна информация, которая в него записывалась
  - при превышении числа одновременно открытых файлов, ОС вместо указателя на файл сгенерирует прерывание, выводящие на экран FILE CAN NOT OPEN

если файл не будет найден "file не существуют" 

работа с файлами в бинарном (двоичном) режиме read/write использует несколько инной механизм доступа к ним, который позволяет в отличие от форматированного доступа, использовать полный путь к файлу, в качестве параметра функции open, котоое возвращает целое значение - номер обработчика файла, при этом используется структура соответствующая структуре DTA операционной системы

признак конца файла - eof, закрыть файл - close

